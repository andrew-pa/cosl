#include "cmmn.h"
#include "tokenizer.h"
#include "ast.h"
#include "parser.h"
#include "code_emitter.h"
#include "hlsl_code_emitter.h"
#include "glsl_code_emitter.h"

/*
Usage (to generate HLSL):	-hlsl <in_file> <out_file>
Usage (to generate GLSL):	-glsl 440 <in_file> <out_file>
*/

int main(int argc, char* argv[])
{
	vector<string> args;
	for (int i = 1; i < argc; ++i) args.push_back(string(argv[i]));
	string infpath, otfpath;
	code_emitter* ce = nullptr;
	if(args[0] == "-hlsl")
	{
		infpath = args[1];
		otfpath = args[2];
		ce = new hlsl_code_emitter();
	}
	else if(args[0] == "-glsl")
	{
		infpath = args[2];
		otfpath = args[3];
		ce = new glsl_code_emitter(args[1]);
	}
	ifstream infs(infpath);
	string in_file;
	string s;
	while (!infs.eof())
	{
		getline(infs, s);
		in_file += s + "\n";
	}
	tokenizer tkn(in_file);
	auto shf = parse_shader(tkn);
	ce->emit(shf);
	ofstream ofs(otfpath);
	ofs.write(ce->out_string().c_str(), ce->out_string().size());
	ofs.flush();
	return 0;
}


















































//////////////////////////////////// ref only!
//////////////////////////////////////tokenizer tkn("	vec4 p = vec4(input.pos, 1.0);"
//////////////////////////////////////	"output.pos = p*wvp;"
//////////////////////////////////////"output.posW = input.pos;"
//////////////////////////////////////"output.normW = input.norm * inw;"
//////////////////////////////////////"output.texc = input.tex; ");
//////////////////////////////////////auto x = parse_stmt(tkn);
////////////////////////////////////
//////////////////////////////////////tokenizer tkn2("{ float depth : depth32; }");
//////////////////////////////////////auto x2 = parse_decl_block(tkn2);
//////////////////////////////////////getchar();
////////////////////////////////////
//////////////////////////////////////tokenizer tkn("$vertex_shader //this should be considered white space\n"
//////////////////////////////////////"	input /*so should this be*/"
//////////////////////////////////////"{"
//////////////////////////////////////"	vec3 pos : position;"
//////////////////////////////////////"	vec3 norm : normal;"
//////////////////////////////////////"	vec3 tex : texcoord;"
//////////////////////////////////////"}"
//////////////////////////////////////
//////////////////////////////////////"	output"
//////////////////////////////////////"{"
//////////////////////////////////////"	vec3 pos : rs_position;"
//////////////////////////////////////"	vec3 posW;"
//////////////////////////////////////"	vec3 normW;"
//////////////////////////////////////"	vec3 texc;"
//////////////////////////////////////"}"
////////////////////////////////////
//////////////////////////////////////"	cbuffer(0)"
//////////////////////////////////////"{"
//////////////////////////////////////"		mat4 wvp;"
//////////////////////////////////////"		mat4 inw;"
//////////////////////////////////////"		vec4 t;"
//////////////////////////////////////"}"
////////////////////////////////////
//////////////////////////////////////"void main()"
//////////////////////////////////////"{"
//////////////////////////////////////"	vec4 p = vec4(input.pos, 1.0);"
//////////////////////////////////////"	output.pos = p*wvp;"
//////////////////////////////////////"	output.posW = input.pos;"
//////////////////////////////////////"	output.normW = input.norm * inw;"
//////////////////////////////////////"	output.texc = input.tex;"
//////////////////////////////////////"}");
////////////////////////////////////tokenizer tkn("$pixel_shader "
////////////////////////////////////	"input"
////////////////////////////////////	"{"
////////////////////////////////////	"	vec3 posW;"
////////////////////////////////////	"	vec3 normW;"
////////////////////////////////////	"	vec2 texc;"
////////////////////////////////////	"}"
////////////////////////////////////
////////////////////////////////////	"output"
////////////////////////////////////	"{"
////////////////////////////////////	"	vec4 col : target0;"
////////////////////////////////////	"}"
////////////////////////////////////
////////////////////////////////////	"texture2D tex(0)"
////////////////////////////////////
////////////////////////////////////	"void main()"
////////////////////////////////////	"{"
////////////////////////////////////	"	output.col = sample2D(tex, input.texc);"
////////////////////////////////////	"}");
////////////////////////////////////auto sh = parse_shader(tkn);
////////////////////////////////////auto ce = new hlsl_code_emmiter;
////////////////////////////////////ce->emit(sh);
/////////////////////////////////////*ce->emit(sh->type);
////////////////////////////////////sh->inpblk->emit(ce);
////////////////////////////////////sh->outblk->emit(ce);
////////////////////////////////////for (auto& cb : sh->cbuffers)
////////////////////////////////////cb->emit(ce);
////////////////////////////////////for (auto& tx : sh->texturedefs)
////////////////////////////////////tx->emit(ce);
////////////////////////////////////for (auto& fn : sh->functions)
////////////////////////////////////fn->emit(ce);*/
////////////////////////////////////cout << ce->out_string();
////////////////////////////////////getchar();